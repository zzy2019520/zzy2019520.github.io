{"meta":{"title":"ZZY","subtitle":"","description":"","author":"张占阳","url":"https://zzy521.com","root":"/"},"pages":[{"title":"关于我","date":"2020-12-20T12:26:06.000Z","updated":"2021-05-20T08:36:35.846Z","comments":false,"path":"about/index.html","permalink":"https://zzy521.com/about/index.html","excerpt":"","text":"能吃能睡,啥都不会."},{"title":"分类","date":"2020-12-20T12:26:06.000Z","updated":"2020-12-20T12:47:16.402Z","comments":false,"path":"categories/index.html","permalink":"https://zzy521.com/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-05-19T09:57:56.000Z","updated":"2021-05-20T08:39:28.971Z","comments":false,"path":"link/index.html","permalink":"https://zzy521.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-20T12:51:11.000Z","updated":"2020-12-20T12:52:44.744Z","comments":false,"path":"tags/index.html","permalink":"https://zzy521.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQLserver数据库时间处理函数","slug":"SQLserver数据库时间处理函数","date":"2021-06-22T02:37:33.000Z","updated":"2021-06-22T03:32:45.857Z","comments":true,"path":"posts/d31c6e08.html","link":"","permalink":"https://zzy521.com/posts/d31c6e08.html","excerpt":"","text":"根据”填报类型”字段的值选择不同的时间字段 convert(varchar,(CASE new_type WHEN &#39;1&#39; THEN DATEADD(HOUR, 8, new_actualfinishtime) WHEN &#39;2&#39; THEN DATEADD(HOUR, 8, new_submitdate) END),23 )submittime 1.当new_type 值为1时取时间为 new_actualfinishtime字段的值,当new_type 值为2时取时间为new_submitdate字段的值. (CASE new_type WHEN ‘1’ THEN new_actualfinishtime WHEN ‘2’ THEN new_submitdate END) 时间 2.现在因为数据库中的时间为0时区,所以转换为北京时间要加上8小时,所以为 (CASE new_type WHEN ‘1’ THEN DATEADD(HOUR, 8, new_actualfinishtime) WHEN ‘2’ THEN DATEADD(HOUR, 8, new_submitdate) END) 时间 3.然后又需要将时间转换为日期格式, SQL Server CONVERT() 函数 CONVERT() 函数是把日期转换为新数据类型的通用函数。 CONVERT() 函数可以用不同的格式显示日期/时间数据。 语法1CONVERT(data_type(length),data_to_be_converted,style) data_type(length) 规定目标数据类型（带有可选的长度）。data_to_be_converted 含有需要转换的值。style 规定日期/时间的输出格式。 可以使用的 style 值： Style ID Style 格式 100 或者 0 mon dd yyyy hh:miAM （或者 PM） 101 mm/dd/yy 102 yy.mm.dd 103 dd/mm/yy 104 dd.mm.yy 105 dd-mm-yy 106 dd mon yy 107 Mon dd, yy 108 hh:mm:ss 109 或者 9 mon dd yyyy hh:mi:ss:mmmAM（或者 PM） 110 mm-dd-yy 111 yy/mm/dd 112 yymmdd 113 或者 13 dd mon yyyy hh:mm:ss:mmm(24h) 114 hh:mi:ss:mmm(24h) 120 或者 20 yyyy-mm-dd hh:mi:ss(24h) 121 或者 21 yyyy-mm-dd hh:mi:ss.mmm(24h) 126 yyyy-mm-ddThh:mm:ss.mmm（没有空格） 130 dd mon yyyy hh:mi:ss:mmmAM 131 dd/mm/yy hh:mi:ss:mmmAM 加过之后为 convert(varchar,(CASE new_type WHEN ‘1’ THEN DATEADD(HOUR, 8, new_actualfinishtime) WHEN ‘2’ THEN DATEADD(HOUR, 8, new_submitdate) END),23 ) 时间 查指定时间范围内的数据因为时间在两个字段内,所以可以使用 (( new_actualfinishtime BETWEEN ‘${START_TIME}’ and’${FINISH_TIME}’) or ( new_submitdate BETWEEN ‘${START_TIME}’ and’${FINISH_TIME}’) ) 其中’${START_TIME}’和’${FINISH_TIME}’为帆软报表内选择的时间,格式为其固定的格式 但是又想只选年月就查到当月的数据 ,所以使用 DateDiff (interval,date1,date2)函数 以interval 指定的方式，返回date2 与date1两个日期之间的差值 date2-date1 interval 格式使用Year和Month,差值都是0 (((DateDiff(month,new_actualfinishtime, ‘${START_TIME}’) = 0 ) and (DateDiff(year,new_actualfinishtime, ‘${START_TIME}’ ) = 0))or( (DateDiff(month,new_submitdate, ‘${START_TIME}’) = 0 ) and (DateDiff(year,new_submitdate, ‘${START_TIME}’ ) = 0))) 同时时间又因为时区问题需要加上8小时,所以再使用 DateAdd (interval,number,date)函数 以interval指定的方式，加上number之后的日期 最后为 (((DateDiff(month,DATEADD(HOUR, 8, new_actualfinishtime), ‘${START_TIME}’) = 0 ) and (DateDiff(year,DATEADD(HOUR, 8, new_actualfinishtime), ‘${START_TIME}’ ) = 0))or( (DateDiff(month,DATEADD(HOUR, 8, new_submitdate), ‘${START_TIME}’) = 0 ) and (DateDiff(year,DATEADD(HOUR, 8, new_submitdate), ‘${START_TIME}’ ) = 0))) 最终的sql 123456789101112131415161718192021222324SELECT convert(varchar,(CASE new_type WHEN &#39;1&#39; THEN DATEADD(HOUR, 8, new_actualfinishtime) WHEN &#39;2&#39; THEN DATEADD(HOUR, 8, new_submitdate) END),23 )submittime, new_ord_sales_idName 业务员, (CASE new_type WHEN &#39;1&#39; THEN &#39;客户拜访&#39; WHEN &#39;2&#39; THEN &#39;工作日志&#39; END)填报类型, location 工作地点, new_jobcontent 工作内容, new_account_idName 客户名称, new_telphone 客户电话, new_entertainfee 招待费, new_accommodationfee 住宿费, new_trafficfee 交通费, new_miscellaneousfee 公杂费, new_other 其他费用, new_dealers_idName 部门FROM appointment WHERE 1&#x3D;1 and new_ord_sales_id&#x3D;&#39;$&#123;id&#125;&#39;--and(( new_actualfinishtime BETWEEN &#39;$&#123;START_TIME&#125;&#39; and&#39;$&#123;FINISH_TIME&#125;&#39;) --or ( new_submitdate BETWEEN &#39;$&#123;START_TIME&#125;&#39; and&#39;$&#123;FINISH_TIME&#125;&#39;) ) and(((DateDiff(month,DATEADD(HOUR, 8, new_actualfinishtime), &#39;$&#123;START_TIME&#125;&#39;) &#x3D; 0 ) and (DateDiff(year,DATEADD(HOUR, 8, new_actualfinishtime), &#39;$&#123;START_TIME&#125;&#39; ) &#x3D; 0))or( (DateDiff(month,DATEADD(HOUR, 8, new_submitdate), &#39;$&#123;START_TIME&#125;&#39;) &#x3D; 0 ) and (DateDiff(year,DATEADD(HOUR, 8, new_submitdate), &#39;$&#123;START_TIME&#125;&#39; ) &#x3D; 0)))order by submittime 时间相关函数SQLserver数据库函数 函数 参数/功能 GetDate( ) 返回系统目前的日期与时间 DateDiff (interval,date1,date2) 以interval 指定的方式，返回date2 与date1两个日期之间的差值 date2-date1 DateAdd (interval,number,date) 以interval指定的方式，加上number之后的日期 DatePart (interval,date) 返回日期date中，interval指定部分所对应的整数值 DateName (interval,date) 返回日期date中，interval指定部分所对应的字符串名称 interval的可选值 值 缩 写（Sql Server） Access 和 ASP 说明 Year Yy yyyy 年 1753 ~ 9999 Quarter Qq q 季 1 ~ 4 Month Mm m 月1 ~ 12 Day of year Dy y 一年的日数,一年中的第几日 1-366 Day Dd d 日，1-31 Weekday Dw w 一周的日数，一周中的第几日 1-7 Week Wk ww 周，一年中的第几周 0 ~ 51 Hour Hh h 时0 ~ 23 Minute Mi n 分钟0 ~ 59 Second Ss s 秒 0 ~ 59 Millisecond Ms - 毫秒 0 ~ 999","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://zzy521.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zzy521.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQLserver","slug":"SQLserver","permalink":"https://zzy521.com/tags/SQLserver/"},{"name":"时间函数","slug":"时间函数","permalink":"https://zzy521.com/tags/%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/"}]},{"title":"CRM钉钉端获取当前用户信息","slug":"CRM钉钉端获取当前用户信息","date":"2021-06-19T00:57:42.000Z","updated":"2021-06-22T02:55:12.109Z","comments":true,"path":"posts/9178543a.html","link":"","permalink":"https://zzy521.com/posts/9178543a.html","excerpt":"","text":"CRM获取用户的信息调用方式为vue接口同步调用,等待接口返回用户的信息之后再根据接口返回的数据进行逻辑判断后执行 返回的SystemUserId为互联用户中的用户id也是销售员工资料中的id 返回的OutterUserDepartId为互联用户中的部门id,也是销售员工资料中的部门id 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; invokeAction &#125; from &quot;vue-xcrmsdk&quot;;export default &#123; data() &#123; return &#123; userInfo:&#123;&#125;, &#125;; &#125;, mounted() &#123; this.getuserinfo().then(() &#x3D;&gt; &#123; &#x2F;&#x2F;获取用户信息之后再执行 &#x2F;&#x2F;此处再写语句会在等待用户信息返回之后再执行 &#125;); &#125;, methods: &#123; &#x2F;&#x2F;获取用户信息 async getuserinfo() &#123; await invokeAction(&quot;new_user_getuserinfo&quot;).then(res &#x3D;&gt; &#123; this.userInfo &#x3D; JSON.parse(res.UserInfo); &#125; ).catch(err &#x3D;&gt; &#123; rt.showErrorToast(err.message); &#125;); &#125;, &#125;&#125;;&lt;&#x2F;script&gt;","categories":[{"name":"CRM","slug":"CRM","permalink":"https://zzy521.com/categories/CRM/"}],"tags":[{"name":"钉钉","slug":"钉钉","permalink":"https://zzy521.com/tags/%E9%92%89%E9%92%89/"},{"name":"用户信息","slug":"用户信息","permalink":"https://zzy521.com/tags/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"},{"name":"vue接口同步调用","slug":"vue接口同步调用","permalink":"https://zzy521.com/tags/vue%E6%8E%A5%E5%8F%A3%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8/"}]},{"title":"二进制形式特殊的数","slug":"二进制形式特殊的数","date":"2021-05-31T06:43:18.000Z","updated":"2021-05-31T07:51:21.034Z","comments":true,"path":"posts/bb493ea5.html","link":"","permalink":"https://zzy521.com/posts/bb493ea5.html","excerpt":"","text":"a&amp;(a-1):去掉a的二进制表示的最后一个1之后得到的数,如果是2的n次幂则得到的会是0 0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0） 0x55555555 = 1010101010101010101010101010101 (偶数位为0，奇数位为1） 0x33333333 = 110011001100110011001100110011 (1和0每隔两位交替出现) 0xcccccccc = 11001100110011001100110011001100 (0和1每隔两位交替出现) 0x0f0f0f0f = 00001111000011110000111100001111 (1和0每隔四位交替出现) 0xf0f0f0f0 = 11110000111100001111000011110000 (0和1每隔四位交替出现)","categories":[{"name":"Java","slug":"Java","permalink":"https://zzy521.com/categories/Java/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://zzy521.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"调用钉钉接口发送工作通知","slug":"调用钉钉接口发送工作通知","date":"2021-04-07T03:21:19.000Z","updated":"2021-05-20T09:19:40.749Z","comments":true,"path":"posts/6a850357.html","link":"","permalink":"https://zzy521.com/posts/6a850357.html","excerpt":"","text":"工作通知消息是以某个微应用的名义推送到员工的工作通知消息，例如生日祝福、入职提醒等。 发送工作通知消息需要注意以下事项： 同一个应用相同消息的内容同一个用户一天只能接收一次。 同一个应用给同一个用户发送消息，企业内部应用一天不得超过500次。 通过设置to_all_user参数全员推送消息，一天最多3次。 超出以上限制**次数**后，接口返回成功，但用户无法接收到。详细的限制说明，请参考工作通知消息限制。 该接口是异步发送消息，接口返回成功并不表示用户一定会收到消息，需要通过获取工作通知消息的发送结果接口查询是否给用户发送成功。 消息类型和样例可参考消息类型与数据格式。 先获取token 再根据token和用户的手机号获取钉钉的userid 根据token和用户的userid发送消息 具体代码如下 代码中的*****要自己填 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.PrintWriter;import com.alibaba.fastjson.JSONObject;public class SendMsg &#123;//调用钉钉接口返回的token---不用填private static String TOKEN =&quot;&quot;;//调用钉钉接口返回的错误值---不用填private String errcode=&quot;&quot;;//根据用户手机号获取的用户的userid---不用填private String userid=&quot;&quot;;//app应用的唯一标识keyprivate final String appkey=&quot;*****&quot;;//应用的密钥。// AppKey和AppSecret可在钉钉开发者后台的应用详情页面获取。private final String appsecret=&quot;*****&quot;;//发送消息时使用的微应用的AgentID。private final String agent_id=&quot;*****&quot;;//是否给所有用户发送消息private final String to_all_user=&quot;false&quot;; /** * 根据手机号和消息内容给用户发送钉钉消息 * @param phone 手机号 * @param msg 消息内容 */ public void SendMessage(String phone,String msg)&#123; getUserid(phone); //如果获取失败获取token重新获取 if(!&quot;0&quot;.equals(errcode))&#123; errcode =&quot;&quot;; getToken(); getUserid(phone); &#125; send(userid,msg); //如果发送失败重新获取token再发送 if(!&quot;0&quot;.equals(errcode)) &#123; getToken(); errcode =&quot;&quot;; send(userid, msg); &#125; &#125; public void getToken() &#123; String URL_1 = &quot;https://oapi.dingtalk.com/gettoken?appkey=&quot;; String URL_2 =&quot;&amp;appsecret=&quot;; String URL = URL_1.concat(appkey).concat(URL_2).concat(appsecret); try &#123; // 创建连接 URL url1 = new URL(URL); HttpURLConnection connection = (HttpURLConnection) url1.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setRequestMethod(&quot;GET&quot;); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); //设置请求头 connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;); connection.connect(); // 读取响应 BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream())); String lines; StringBuffer sb = new StringBuffer(&quot;&quot;); while ((lines = reader.readLine()) != null) &#123; lines = new String(lines.getBytes(), &quot;utf-8&quot;); sb.append(lines); &#125; reader.close(); // 断开连接 connection.disconnect(); String obj= String.valueOf(sb); JSONObject jsonObject = JSONObject.parseObject(obj); TOKEN =jsonObject.getString(&quot;access_token&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 根据token值和用户手机号获取用户的钉钉userid * @param phone 用户手机号 */ public void getUserid(String phone) &#123; String URL_1 = &quot;https://oapi.dingtalk.com/user/get_by_mobile?access_token=&quot;; String URL_2 =&quot;&amp;mobile=&quot;; String URL = URL_1.concat(TOKEN).concat(URL_2).concat(phone); // String userid=&quot;&quot;; try &#123; // 创建连接 URL url1 = new URL(URL); HttpURLConnection connection = (HttpURLConnection) url1.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setRequestMethod(&quot;GET&quot;); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); //设置请求头 connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;); connection.connect(); // 读取响应 BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream())); String lines; StringBuffer sb = new StringBuffer(&quot;&quot;); while ((lines = reader.readLine()) != null) &#123; lines = new String(lines.getBytes(), &quot;utf-8&quot;); sb.append(lines); &#125; reader.close(); // 断开连接 connection.disconnect(); String obj= String.valueOf(sb); JSONObject jsonObject = JSONObject.parseObject(obj); userid =jsonObject.getString(&quot;userid&quot;); errcode =jsonObject.getString(&quot;errcode&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 根据token和用户的userid发送消息 * @param userid 用户的钉钉id * @param msg 发送消息的内容 */ public void send(String userid,String msg) &#123; String URL_title = &quot;https://oapi.dingtalk.com/topapi/message/corpconversation/asyncsend_v2?access_token=&quot;; String URL=URL_title.concat(TOKEN); try &#123; // 创建连接 URL url = new URL(URL); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setDoOutput(true); connection.setDoInput(true); connection.setRequestMethod(&quot;POST&quot;); connection.setUseCaches(false); connection.setInstanceFollowRedirects(true); //设置请求头 connection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;); connection.connect(); // POST请求,包装成json数据 PrintWriter out = new PrintWriter(new OutputStreamWriter(connection.getOutputStream(),&quot;utf-8&quot;)); JSONObject obj = new JSONObject(); JSONObject obj1 = new JSONObject(); JSONObject obj2 = new JSONObject(); //消息内容 obj2.put(&quot;content&quot;,msg); obj1.put(&quot;text&quot;,obj2); //消息格式 obj1.put(&quot;msgtype&quot;,&quot;text&quot;); obj.put(&quot;msg&quot;, obj1); //是否给所有用户发送消息 obj.put(&quot;to_all_user&quot;,to_all_user); //发现消息的程序id obj.put(&quot;agent_id&quot;,agent_id); //用户id obj.put(&quot;userid_list&quot;,userid); out.println(obj); out.flush(); out.close(); // 读取响应 BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream())); String lines; StringBuffer sb = new StringBuffer(&quot;&quot;); while ((lines = reader.readLine()) != null) &#123; lines = new String(lines.getBytes(), &quot;utf-8&quot;); sb.append(lines); &#125; reader.close(); // 断开连接 connection.disconnect(); String obj11= String.valueOf(sb); JSONObject jsonObject = JSONObject.parseObject(obj11); errcode =jsonObject.getString(&quot;errcode&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://zzy521.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"钉钉消息","slug":"钉钉消息","permalink":"https://zzy521.com/tags/%E9%92%89%E9%92%89%E6%B6%88%E6%81%AF/"},{"name":"java","slug":"java","permalink":"https://zzy521.com/tags/java/"}]},{"title":"解决NavicatPremium连接SQLServer出现未发现数据源名称并且未指定默认驱动","slug":"解决NavicatPremium连接SQLServer出现未发现数据源名称并且未指定默认驱动","date":"2021-03-30T02:34:02.000Z","updated":"2021-05-20T09:21:31.038Z","comments":true,"path":"posts/21754c85.html","link":"","permalink":"https://zzy521.com/posts/21754c85.html","excerpt":"","text":"报错：[navicat premium] [IM002] [Microsoft][ODBC 驱动程序管理器] 未发现数据源名称并且未指定默认驱动程序 进入Navicat的安装目录,找到下边的文件,点击安装,重新打开数据库即可.","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://zzy521.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zzy521.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQLServer","slug":"SQLServer","permalink":"https://zzy521.com/tags/SQLServer/"}]},{"title":"Java中a=a++的问题","slug":"Java中a=a++的问题","date":"2021-03-23T09:41:17.000Z","updated":"2021-05-20T08:54:03.477Z","comments":true,"path":"posts/dad1e78f.html","link":"","permalink":"https://zzy521.com/posts/dad1e78f.html","excerpt":"","text":"int a=0;a=a++;生成的字节码是： 0 iconst_0 —–0压入栈顶 1 istore_1 [a] —–栈顶值（0）存入局部变量1（a） 2 iload_1 [a] —–变量1的值压入栈顶（值为0）(a++效果) 3 iinc 1 1 [a] —–变量1自加（a++操作，自加后变量1的值为1） 6 istore_1 [a] —–将栈顶值（0）存入变量1（=操作） a的值依次变化为：0-&gt;1-&gt;0 运算符的优先级中++和–仅次于(),而a++正常的逻辑是++在下一行才会生效,但这里使用的是同一个变量,所以这里是先把右边运算的结果(也就是a的原始值0)压入栈,然后再去计算a++,由于=的优先级是最低的,所以最后再将运算过的值赋值给左边的a int a=0;a=++a;生成的字节码是： 0 iconst_0 —–0压入栈顶 1 istore_1 [a] —–栈顶值（0）存入局部变量1（a） 2 iinc 1 1 [a] —–变量1自加（++a操作，自加后变量1的值为1） 5 iload_1 [a] —–变量1的值压入栈顶（值为1）(++a效果) 6 istore_1 [a] —–将栈顶值（1）存入变量1（=操作） a的值依次变化为：0-&gt;1-&gt;1 int a=0;a=(a++)+(++a);0 iconst_0 —–0压入栈顶 1 istore_1 [a] —–栈顶值（0）存入局部变量1（a） 2 iload_1 [a] —–变量1的值压入栈顶（值为0）(a++效果) 3 iinc 1 1 [a] —–变量1自加（a++操作，自加后变量1的值为1） 6 iinc 1 1 [a] —–变量1自加（++a操作，自加后变量1的值为2） 9 iload_1 [a] —–变量1的值压入栈顶（值为2）(++a效果) 10 iadd —–栈顶两值（0，2）相加（结果为2），并存入栈顶 11 istore_1 [a]—–将栈顶值（2）存入变量1（=操作） a的值依次变化为：0-&gt;1-&gt;2-&gt;2 这里是先计算括号里边的值,左边的括号是先存a的值,然后压入栈用来计算之后的a++(由于有++才有了这一步),这时候左边的括号内容进行运算,然后a自加;右边括号先进行a自加然后进行运算,这时候右边括号的值为2,然后赋值给a 总结:应该是++的优先级最高,所以a++是会先取a的值,然后a进行自加,然后使用取出的值进行运算,最后在进行=的赋值操作,所以是因为=的优先级最低,所以=的赋值覆盖了a自加的值. 但在实际编码的过程中还是尽量不要用不好理解的代码.","categories":[{"name":"Java","slug":"Java","permalink":"https://zzy521.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zzy521.com/tags/Java/"},{"name":"a++","slug":"a","permalink":"https://zzy521.com/tags/a/"}]},{"title":"Java位运算","slug":"Java位运算","date":"2021-03-23T02:05:47.000Z","updated":"2021-05-20T08:53:51.554Z","comments":true,"path":"posts/f789481e.html","link":"","permalink":"https://zzy521.com/posts/f789481e.html","excerpt":"","text":"位运算符 符号 描述 运算规则 &amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，不同为1 ~ 取反 0变1，1变0 &lt;&lt; 左移 各二进位全部左移若干位，高位丢弃，低位补0.相当于乘2 &gt;&gt; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 位运算符常用方式用位运算做加法123456789101112131415//step1:异或查看两个数进行加法操作后的结果//step2:与运算计算出想对应的位置的进位结果，然后左移一位//b代表的是两数相加是否有进位，有的话就继续，没有的话就结束得出相加后的答案public class Solution&#123; public int Add(int a,int b)&#123; while(b != 0)&#123; int temp = a ^ b;//计算出相对应的位置相加后的结果 b = (a &amp; b) &lt;&lt; 1;//计算出想对应的位置的进位，然后左移一位 a = temp; &#125; return a; &#125;&#125;//这个其实可以简写成return (a^b)+((a&amp;b)&lt;&lt;1); 用位运算求平均数123public int average(int a,int b)&#123; return (a &amp; b)+((a ^ b) &gt;&gt; 1);&#125; 原理:每一位都0,1有两种情况,所以对应的每一位相加有3种情况 1.(0+0):0&amp;0和0^0都是0 2.(1+0)或(0+1):1&amp;0为0,1^0为1;而1+0为1,所以相加的结果刚好是与的结果,要求平均数所以右移一位,相当于除以二 3.(1+1):1&amp;1为1,1^1为0,而1+1为2,所以刚好是异或的结果刚好是平均数 二进制中1的个数12345678910111213public class Solution&#123; public int NumberOf1(int a)&#123; if(a == 0||a == 1)&#123; return a; &#125; int count = 0; while(a != 0)&#123; count++; a = a &amp; (a-1); &#125; return count; &#125;&#125; 原理:a = a &amp; (a-1); a异或a-1的结果刚好为a去掉二进制时的最后一位1的结果 判断一个数的奇偶性1234567public void Test(int a)&#123; if((a &amp; 1)==0)&#123; System.out.println(&quot;a是偶数&quot;); &#125;else&#123; System.out.println(&quot;a是奇数&quot;); &#125;&#125; 两数的中位数1234public void Test(int a,int b)&#123; //通过位运算不会造成溢出 int mid = a - ((a - b) &gt;&gt; 1);&#125; 不使用第三个变量的情况下交换两个变量的值1234567//原理：运用异或的特性//A ^ B = C --&gt; C ^ A = B --&gt; C ^ B = Apublic void exchange(int a,int y)&#123; x = x ^ y; y = x ^ y; x = x ^ y;&#125; 原理:x = x ^ y;y = x ^ y;x = x ^ y; z = x ^ y;y = z ^ y;x = z ^ y;","categories":[{"name":"Java","slug":"Java","permalink":"https://zzy521.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zzy521.com/tags/Java/"},{"name":"位运算","slug":"位运算","permalink":"https://zzy521.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"Java类型转换","slug":"Java类型转换","date":"2021-03-20T07:27:14.000Z","updated":"2021-05-20T08:53:15.909Z","comments":true,"path":"posts/16b8fe02.html","link":"","permalink":"https://zzy521.com/posts/16b8fe02.html","excerpt":"","text":"Java一共有八种基本数据类型 整数类型 1字节:byte 表数范围为-128(-27)~127(27-1) 2字节:short -32768(-215)~32767 (215-1)(大约为32万) 4字节:int -2147483648(-231)~2147483647(231-1)(大约为21亿) 8字节:long -263~263-1 字符类型 2字节:char 浮点类型 4字节:float 8字节:double 布尔类型 boolean 自动类型转换Java的所有字符型变量可以相互转换,如果系统支持把某种类型的变量直接赋值给另一种基本类型的变量,这种方式称为自动类型转换.当把一个表数范围小的数值或变量直接赋值给另一个表数范围大的变量时,系统可以进行自动类型转换;否则就需要强制转换. 支持自动类型转换的类型为:byte→short→int→long→float→double和char→int→long→float→double 字符串和任何基本类型的值进行连接运算时,基本类型的值都会自动转化为字符串类型 强制类型转换当需要把箭头右边的类型转换为箭头左边的类型时,必须进行强制类型转换强制类型转换的语法格式是:(targetType)value,强制类型转换的运算符是().转换时要注意数据溢出问题. 字符串类型与其他类型的转换其它类型向字符串的转换 调用类的串转换方法:X.toString(); 自动转换:X+“”; 使用String的方法:String.valueOf(X); 字符串作为值,向其它类型的转换 先转换成相应的封装器实例,再调用对应的方法转换成其它类型 例如，字符中“32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。 也可以用:Double.valueOf(“32.1”).doubleValue() 静态parseXXX方法 1234567String s = &quot;1&quot;;byte b = Byte.parseByte( s );short t = Short.parseShort( s );int i = Integer.parseInt( s );long l = Long.parseLong( s );Float f = Float.parseFloat( s );Double d = Double.parseDouble( s ); Character的getNumericValue(char ch)方法 返回指定的 Unicode 字符表示的 int 值。 其它实用数据类型转换Date类与其它数据类型的相互转换整型和Date类之间并不存在直接的对应关系，只是你可以使用int型为分别表示年、月、日、时、分、秒，这样就在两者之间建立了一个对应关系，在作这种转换时，你可以使用Date类构造函数的三种形式： ①Date(int year, int month, int date)：以int型表示年、月、日 ②Date(int year, int month, int date, int hrs, int min)：以int型表示年、月、日、时、分 ③Date(int year, int month, int date, int hrs, int min, int sec)：以int型表示年、月、日、时、 分、秒 在长整型和Date类之间有一个很有趣的对应关系，就是将一个时间表示为距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。对于这种对应关系，Date类也有其相应的构造函数：Date(long date)。 获取Date类中的年、月、日、时、分、秒以及星期你可以使用Date类的getYear()、getMonth()、getDate()、getHours()、getMinutes()、getSeconds()、getDay()方法，你也可以将其理解为将Date类转换成int。 而Date类的getTime()方法可以得到我们前面所说的一个时间对应的长整型数，与包装类一样，Date类也有一个toString()方法可以将其转换为String类。 有时我们希望得到Date的特定格式，例如20020324，我们可以使用以下方法，首先在文件开始引入， 12345678910111213141516171819202122232425import java.text.SimpleDateFormat;import java.util.*;java.util.Date date = new java.util.Date();//如果希望得到YYYYMMDD的格式SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyyMMDD&quot;);String dateFormat=sdf.format(date);//如果希望分开得到年，月，日SimpleDateFormat sy=newSimpleDateFormat(&quot;yyyy&quot;);SimpleDateFormat sm=new SimpleDateFormat(&quot;MM&quot;);SimpleDateFormat sd=new SimpleDateFormat(&quot;dd&quot;);String syear=sy.format(date);String smon=sm.format(date);String sday=sd.format(date); js中将Data转换成String类型1234567891011121314151617//对Date的扩展，将 Date转化为指定格式的String// 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q) 可以用 1-2个占位符// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3位的数字)//eg:(new Date()).pattern(&quot;yyyy-MM-dd hh:mm:ss.S&quot;) ==&gt;2006-07-02 08:09:04.423(new Date()).pattern(&quot;yyyy-MM-dd E HH:mm:ss&quot;) ==&gt;2009-03-10 二 20:09:04(new Date()).pattern(&quot;yyyy-MM-dd EE hh:mm:ss&quot;) ==&gt;2009-03-10 周二 08:09:04(new Date()).pattern(&quot;yyyy-MM-dd EEE hh:mm:ss&quot;)==&gt; 2009-03-10 星期二 08:09:04(new Date()).pattern(&quot;yyyy-M-d h:m:s.S&quot;) ==&gt;2006-7-2 8:9:4. 字符型转时间型（2005-10-1） reportdate_str ＝ “2005-10-01”； reportdate_str ＝ reportdate_str ＋ “ 00:00:00.0” reportdate = java.sql.Timestamp.valueOf(reportdate_str);","categories":[{"name":"Java","slug":"Java","permalink":"https://zzy521.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zzy521.com/tags/Java/"},{"name":"类型转换","slug":"类型转换","permalink":"https://zzy521.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"}]},{"title":"Python处理Excel文件","slug":"Python处理Excel文件","date":"2021-02-25T03:42:02.000Z","updated":"2021-05-20T09:12:44.193Z","comments":true,"path":"posts/6c0fc8c8.html","link":"","permalink":"https://zzy521.com/posts/6c0fc8c8.html","excerpt":"","text":"做了一个从Excel中筛选需要的列和行；并根据内容不同放到不同的Excel中的程序 导入需要的包123456789import sysimport xlrdimport xlwtfrom datetime import datetimefrom xlrd import xldate_as_tupleimport tkinterimport osfrom tkinter import filedialogfrom tkinter import messagebox 选取Excel文件并获取文件名和文件路径123456from tkinter import filedialogtkinter.Tk().withdraw() # 使用tk选择文件时会出现一个框框，不影响使用但会看着很难受，所以将Tkinter.Tk()实例隐藏Filepath = filedialog.askopenfilename(title=u&#x27;选择文件&#x27;)#获取文件路径并将选择框标题设置为选择文件Filename = os.path.basename(Filepath)#根据文件路径获取文件名，后边我生成新的文件需要根据选择的文件来命名if Filepath == &#x27;&#x27;:#如果弹出的文件选择框未选择就关闭会导致文件路径为空，下边的代码执行会出错，所以路径为空直接结束程序 sys.exit() 读取Excel文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x27;&#x27;&#x27;读取工作表&#x27;&#x27;&#x27;data = xlrd.open_workbook(Filepath)#根据上边的路径读取Excel文件table = data.sheets()[0]#用索引方式获取第一个sheet&#x27;&#x27;&#x27;总行数&#x27;&#x27;&#x27;nrows = table.nrows&#x27;&#x27;&#x27;总列数&#x27;&#x27;&#x27;ncols = table.ncols&#x27;&#x27;&#x27;获取第二行的列名称&#x27;&#x27;&#x27;columnName = table.row_values(1)#excel中第二行为列名，用列表记录&#x27;&#x27;&#x27;获取需要的列的字典&#x27;&#x27;&#x27;saveColumn = [&#x27;任务号&#x27;, &#x27;物料编码&#x27;, &#x27;零件图号&#x27;, &#x27;数量&#x27;, &#x27;材质&#x27;, &#x27;尺寸&#x27;, &#x27;工序&#x27;, &#x27;完工日期&#x27;, &#x27;备料日期&#x27;, &#x27;成型日期&#x27;, &#x27;仓库&#x27;, &#x27;定额&#x27;, &#x27;工段&#x27;, &#x27;组件&#x27;, &#x27;外协&#x27;, &#x27;批次&#x27;]#需要保存的列的名称columnNameDictionary = &#123;&#125;#声明一个字典来存储需要的列在excel中对应的列号for i in range(ncols): if columnName[i] in saveColumn:#如果第二列中的列名在需要保存的列的列表中；则将列名和列号存到字典中 columnNameDictionary[columnName[i]] = i&#x27;&#x27;&#x27;获取需要的数据列数据，去掉不需要的列数据&#x27;&#x27;&#x27;dataContent = []for key, value in columnNameDictionary.items():#根据列名字典中列名对应的数据列去获取数据内容 dataContent.append(table.col_values(value, start_rowx=1, end_rowx=nrows))&#x27;&#x27;&#x27;去掉不需要的行数据,同时将列表存储数据的方式由列转为行&#x27;&#x27;&#x27;ncols = len(dataContent) # 列数量----更新行列值nrows = len(dataContent[0]) # 行数量&#x27;&#x27;&#x27;需要将材质列等于——的值整行删除&#x27;&#x27;&#x27;material = 0 # 材质的列号for i in range(nrows): # 找到材质的列号 if dataContent[i][0] == &#x27;材质&#x27;: material = i breakfinalDataContent = []#用来存储最终需要的行列数据，按行存储for i in range(nrows):#i为行数 temp = []#暂存数据的列表 if dataContent[material][i] != &#x27;——&#x27;:#如果材质不等于——则将第i行数据读出 for j in range(ncols): temp.append(dataContent[j][i]) finalDataContent.append(temp)#将读到的数据保存 temp = []&#x27;&#x27;&#x27;更新列名字典和行列数&#x27;&#x27;&#x27;ncols = len(finalDataContent[0]) # 列数量nrows = len(finalDataContent) # 行数量columnNameDictionary.clear()for i in range(ncols): columnNameDictionary[finalDataContent[0][i]] = i 修改Excel内需要修改的数据1234567891011121314&#x27;&#x27;&#x27;修改数据内容;按外协厂家进行分组-----为了减少循环次数放到了一块&#x27;&#x27;&#x27;outsourcSet = set() # 创建外协集合for i in range(nrows): if i &gt; 0: # 第一行为列名，从第二行开始遍历 “零件图号”列将所有字母改为小写、“.”改为“-”、“艺”改为“y” finalDataContent[i][columnNameDictionary[&#x27;零件图号&#x27;]] = finalDataContent[i][columnNameDictionary[&#x27;零件图号&#x27;]].lower() finalDataContent[i][columnNameDictionary[&#x27;零件图号&#x27;]] = finalDataContent[i][columnNameDictionary[&#x27;零件图号&#x27;]].replace(&#x27;.&#x27;, &#x27;-&#x27;) finalDataContent[i][columnNameDictionary[&#x27;零件图号&#x27;]] = finalDataContent[i][columnNameDictionary[&#x27;零件图号&#x27;]].replace(&#x27;艺&#x27;, &#x27;y&#x27;) finalDataContent[i][columnNameDictionary[&#x27;数量&#x27;]] = int(finalDataContent[i][columnNameDictionary[&#x27;数量&#x27;]]) finalDataContent[i][columnNameDictionary[&#x27;完工日期&#x27;]] = datetime(*xldate_as_tuple(finalDataContent[i][columnNameDictionary[&#x27;完工日期&#x27;]], 0)).strftime(&#x27;%Y-%m-%d&#x27;) finalDataContent[i][columnNameDictionary[&#x27;备料日期&#x27;]] = datetime(*xldate_as_tuple(finalDataContent[i][columnNameDictionary[&#x27;备料日期&#x27;]], 0)).strftime(&#x27;%Y-%m-%d&#x27;) finalDataContent[i][columnNameDictionary[&#x27;成型日期&#x27;]] = datetime(*xldate_as_tuple(finalDataContent[i][columnNameDictionary[&#x27;成型日期&#x27;]], 0)).strftime(&#x27;%Y-%m-%d&#x27;) outsourcSet.add(finalDataContent[i][columnNameDictionary[&#x27;外协&#x27;]])outsourc = list(outsourcSet)#得到的分为不同文件的厂家名 str.lower()是将字符串的字母全转为小写 str.replace(&#39;艺&#39;, &#39;y&#39;)是将字符串的“艺”都转为“y” finalDataContent[i][columnNameDictionary[&#39;完工日期&#39;]] = datetime(*xldate_as_tuple(finalDataContent[i][columnNameDictionary[&#39;完工日期&#39;]], 0)).strftime(&#39;%Y-%m-%d&#39;) finalDataContent[i][columnNameDictionary[&#39;完工日期&#39;]]的 值在读取过后被转为了数值，应该展示为日期，所以使用 datetime(*xldate_as_tuple(finalDataContent[i][columnNameDictionary[&#39;完工日期&#39;]], 0)).strftime(&#39;%Y-%m-%d&#39;) 来转为日期型并重新赋值给它 将data由读出来的数值转为日期的方法为datetime(*xldate_as_tuple(data, 0)).strftime(&#39;%Y-%m-%d&#39;) 将数据存储为Excel文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 设置样式# VERT_TOP = 0x00 上端对齐# VERT_CENTER = 0x01 居中对齐（垂直方向上）# VERT_BOTTOM = 0x02 低端对齐# HORZ_LEFT = 0x01 左端对齐# HORZ_CENTER = 0x02 居中对齐（水平方向上）# HORZ_RIGHT = 0x03 右端对齐style = xlwt.XFStyle()al = xlwt.Alignment()al.horz = 0x02 # 设置水平居中al.vert = 0x01 # 设置垂直居中style.alignment = alfor i in range(len(outsourc)): name = Filepath.replace(&#x27;★模板★&#x27;, &#x27;【&#x27; + outsourc[i] + &#x27;】&#x27;) # 创建excel文件 filename = xlwt.Workbook() # 给工作表命名 sheet = filename.add_sheet(data.sheet_names()[0]) a = b = 0 for j in range(nrows): style2 = xlwt.easyxf(&#x27;font:height 360;&#x27;) # 18pt,类型小初的字号 row = sheet.row(j) row.set_style(style2) if j == 0: for k in range(ncols): sheet.write(a, b, finalDataContent[j][k], style) b += 1 b = 0 a += 1 else: if finalDataContent[j][columnNameDictionary[&#x27;外协&#x27;]] == outsourc[i]: finalDataContent[j][columnNameDictionary[&#x27;外协&#x27;]] = &#x27;外协&#x27; + finalDataContent[j][columnNameDictionary[&#x27;外协&#x27;]] for k in range(ncols): sheet.write(a, b, finalDataContent[j][k], style) b += 1 b = 0 a += 1&#x27;&#x27;&#x27;设置每一列的宽度&#x27;&#x27;&#x27; sheet.col(0).width = 256 * 14 sheet.col(1).width = 256 * 14 sheet.col(2).width = 256 * 20 sheet.col(3).width = 256 * 5 sheet.col(4).width = 256 * 10 sheet.col(5).width = 256 * 20 sheet.col(6).width = 256 * 20 sheet.col(7).width = 256 * 14 sheet.col(8).width = 256 * 14 sheet.col(9).width = 256 * 14 sheet.col(10).width = 256 * 10 sheet.col(11).width = 256 * 10 sheet.col(12).width = 256 * 14 sheet.col(13).width = 256 * 14 sheet.col(14).width = 256 * 14 sheet.col(15).width = 256 * 20 filename.save(name) 设置单元格数据居中的方式1234567891011121314# 设置样式# VERT_TOP = 0x00 上端对齐# VERT_CENTER = 0x01 居中对齐（垂直方向上）# VERT_BOTTOM = 0x02 低端对齐# HORZ_LEFT = 0x01 左端对齐# HORZ_CENTER = 0x02 居中对齐（水平方向上）# HORZ_RIGHT = 0x03 右端对齐style = xlwt.XFStyle()al = xlwt.Alignment()al.horz = 0x02 # 设置水平居中al.vert = 0x01 # 设置垂直居中style.alignment = alsheet.write(a, b, finalDataContent[j][k], style)#在第a行第b列填入finalDataContent[j][k]的数据，格式为style 设置单元格高度123style2 = xlwt.easyxf(&#x27;font:height 360;&#x27;) # 18pt,类型小初的字号 row = sheet.row(j)#在写第j行的时候设置它的高度 row.set_style(style2) 设置单元格高度1sheet.col(0).width = 256 * 14#设置单元格第1列的宽度；256为一个字符的宽度 将数据存储为txt文件12345678910111213for i in range(len(outsourc)): name = Filepath.replace(&#x27;★模板★.xls&#x27;, &#x27;【&#x27; + outsourc[i] + &#x27;】.txt&#x27;) txtData = open(name, &#x27;w&#x27;)#以读方式打开，如果有数据会被清空 count = 0 # 记录行号 for j in range(nrows): if j &gt; 0: if finalDataContent[j][columnNameDictionary[&#x27;外协&#x27;]] == &#x27;外协&#x27; + outsourc[i]: if count != 0:#如果不是第一行则先加换行再输出；需求最后没有空行，最后不能换行，所以换行在写每一行之前 print(&#x27;&#x27;, file=txtData)#print打印会默认换行，所以直接打印空字符 count += 1 for k in range(ncols): print(finalDataContent[j][k], end=&#x27;\\t&#x27;, file=txtData)#写入每个数据后用制表符分隔 txtData.close()#关闭文件对象 完成后弹出提示框1messagebox.showinfo(&quot;提示&quot;, &quot;文件分解完成&quot;) 打包文件安装pyinstallerpip install pyinstaller 打包pyinstaller -F -w PlansToBreakUp.py 需要在文件在目录下运行 -w是去掉运行时的黑框","categories":[{"name":"Python","slug":"Python","permalink":"https://zzy521.com/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zzy521.com/tags/python/"},{"name":"excel","slug":"excel","permalink":"https://zzy521.com/tags/excel/"}]},{"title":"服务器添加EOS的workspace功能","slug":"服务器添加EOS的workspace功能","date":"2021-02-20T01:13:00.000Z","updated":"2021-05-20T09:00:05.813Z","comments":true,"path":"posts/24cd4f39.html","link":"","permalink":"https://zzy521.com/posts/24cd4f39.html","excerpt":"","text":"1.复制文件到服务器将Windows下边的workspace文件夹拷贝到服务器tomcat目录下的webapps文件夹中 ，workspace文件夹为EOS安装路径下的\\apache-tomcat-7.0.54\\webapps\\workspace 2.修改配置文件这个时候就可以访问登录界面但实际无法登录，需要修改xml文件中的IP地址的端口号 修改uddi-address.xml文件中的内容，文件地址为服务器tomcat安装目录下的apache-tomcat-7.0.54/webapps/workspace/WEB-INF/classes/uddi-address.xml 12345678910111213&lt;uddi__address id=&quot;default&quot;&gt; &lt;name&gt;localserver&lt;/name&gt; &lt;logicName&gt;default&lt;/logicName&gt; &lt;type&gt;remote&lt;/type&gt; &lt;description&gt;uddi-config.xml at &quot; Work Space&quot;&lt;/description&gt; &lt;uddiHost&gt;10.8.32.159&lt;/uddiHost&gt; &lt;uddiPort&gt;8090&lt;/uddiPort&gt; &lt;uddiWebContext&gt;default&lt;/uddiWebContext&gt; &lt;uddiUserID&gt;bps&lt;/uddiUserID&gt; &lt;uddiPassword&gt;000000&lt;/uddiPassword&gt; &lt;uddiAdminPort&gt;6200&lt;/uddiAdminPort&gt; &lt;/uddi__address&gt;&lt;/uddi__address__list&gt; 将uddiHost修改为服务器ip地址，将uddiPort修改为服务器tomcat的端口号","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zzy521.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"EOS","slug":"EOS","permalink":"https://zzy521.com/tags/EOS/"},{"name":"Linux","slug":"Linux","permalink":"https://zzy521.com/tags/Linux/"}]},{"title":"将Java程序打包为exe文件并和jre一起打包为安装包","slug":"将Java程序打包为exe文件并和jre一起打包为安装包","date":"2021-02-19T03:36:00.000Z","updated":"2021-05-20T09:09:06.380Z","comments":true,"path":"posts/eeae6a0e.html","link":"","permalink":"https://zzy521.com/posts/eeae6a0e.html","excerpt":"","text":"1.将Java程序导出的jar文件打包为exe文件1.1打开安装好的exe4j软件，首先看到的是一个欢迎界面，直接【next】就可以了 1.2在第二步中我们选择【JAR in EXE mode】，然后【next】 1.3.第三步中需要输入程序的缩写名字和指明输出目录，就是程序的保存目录，按照自己的情况设置就行，没啥特别要求，然后【next】 1.4.需要指定程序的名字，设置程序的图标，注意，程序图标要用ico格式的图片 1.5.然后我们在左边的菜单栏中选择【32 bit or 64 bit】，勾上【Generate 64 bit executeable】，不勾选为32位，勾选为64位 1.6.添加我们的jar包，点击右边绿色的 “+”号，然后选择【Archive】，打开浏览目录，找到我们的jar包，然后选择【打开】，【ok】 1.7.然后选择主类，在Main class后面，选择【浏览】，找到主类，添加上主类，然后【next】 1.8.设置JRE的最小最高版本，我们根据自己的情况设置，小版本设置成1.5，大版本设置成1.8，就行 1.9.然后点击【Advanced Options】，选择【Search sequence】，将我们的JRE添加到软件中，这样的话，我们的代码可以在别的没有安装Java环境的电脑上运行；点击右边的添加，选择【Directory】，然后选择【浏览】，找到我们的JRE，然后添加（添加之后把前面的删掉然后加一个点，这里我写的是.\\jre1.8.0_73，使用相对路径，之后把生成的程序和jre的文件夹拷贝到同一个文件夹下） 1.10.然后点击左侧的【Preferred VM】，选择【Client hotspot VM】，然后【next】 1.11.其余的步骤直接默认就行了，这样生成的exe文件就能正常运行了！ 2.将jre环境和exe文件一起打包为程序安装包需要安装Inno Setup 菜单栏→新建，打开脚本向导 直接下一步 填写应用程序名称和应用程序版本，其他两个可以选填。 这一步可以默认，应用程序所在的文件夹默认为上一步填的应用程序名称 主执行文件选择用exe4j打包好的那个exe文件，然后点击添加文件夹选中jre文件夹，下一步 直接下一步 接着下一步 继续下一步 还是下一步 选择安装程序的保存位置、安装程序文件名、安装程序的图标。安装密码为可选项 继续下一步 点击完成 在生成的脚本中找到**[Files],然后找到刚刚添加的文件夹路径，在文件加路径后的&#123;app&#125;后边加上\\jre，jre就是程序安装后在安装路径下生成的文件夹名称，这里文件夹的名称与上边1.9中填写的路径要保持一致**，如果上边是跟我的文件夹名一样的，那这里也要写为.\\jre1.8.0_73。 然后在菜单栏点击构建→编译即可。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://zzy521.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zzy521.com/tags/Java/"},{"name":"exe","slug":"exe","permalink":"https://zzy521.com/tags/exe/"}]},{"title":"EOS中Restful服务的开发与调用","slug":"EOS实现restful","date":"2021-01-20T09:21:05.000Z","updated":"2021-05-20T08:58:47.307Z","comments":true,"path":"posts/5a3d390e.html","link":"","permalink":"https://zzy521.com/posts/5a3d390e.html","excerpt":"","text":"开发Restful服务创建服务实现类创建一个class，添加下列注解和代码，配置接口访问的入口，需要注意的是Path中的路径必须是与web.xml中resteasyservlet配置的相同，否则将无法访问到接口，此处我们配置在/rest/services下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.xcmg.service;import java.util.*;import javax.sql.DataSource;import javax.ws.rs.GET;import javax.ws.rs.POST;import javax.ws.rs.Path;import javax.ws.rs.PathParam;import javax.ws.rs.Produces;import com.alibaba.fastjson.JSON;import com.eos.common.connection.DataSourceHelper;import com.eos.engine.component.ILogicComponent;import com.eos.foundation.data.DataObjectUtil;import com.eos.workflow.api.BPSServiceClientFactory;import com.primeton.components.rest.annotation.JSONParam;import com.primeton.ext.engine.component.LogicComponentFactory;import com.xcmg.getRsInfo;import commonj.sdo.DataObject;@Path(&quot;/rest/services/RoleService&quot;)@Produces(&#123;&quot;application/json&quot;&#125;)public class ProcessStartService &#123; @POST @Path(&quot;/addProcess&quot;) //新增数据 public String addRole(@JSONParam(&quot;role&quot;)DataObject[] role)throws Throwable&#123; //获取后台返回值 Map ms= new HashMap(); //调用数据模型 role = DataObjectUtil.convertDataObjects(role,&quot;com.primeton.eos.Advice.Advice&quot;,false); System.err.println(role.length); for (int i = 0; i &lt; role.length; i++) &#123; Object[] inParameters = &#123; role[i].get(&quot;proposer&quot;), role[i].get(&quot;department&quot;), role[i].get(&quot;phone&quot;), role[i].get(&quot;category&quot;), role[i].get(&quot;carrydepartment&quot;), role[i].get(&quot;proposal&quot;), role[i].get(&quot;actuality&quot;), role[i].get(&quot;improvement&quot;) &#125;; //打印数据 Object[] params = new Object[1]; params[0] = role; Object[] result = null; //设置登录用户 String userid= (String)role[i].get(&quot;state&quot;); BPSServiceClientFactory.getLoginManager().setCurrentUser(userid, &quot;sysadmin&quot;); //构件名称 ILogicComponent logicComponent = LogicComponentFactory.create(&quot;com.primeton.eos.phoneProcess&quot;); //逻辑流名称 result = logicComponent.invoke(&quot;StartProcess&quot;, inParameters); String count = (String)result[0]; Long id = (Long)result[1]; System.err.println(&quot;-----------------------》》&quot;+count); if(count.equals(&quot;1&quot;))&#123; ms.put(&quot;errorCode&quot;,&quot;00100&quot;); ms.put(&quot;errorMsg&quot;, &quot;新增数据成功&quot;); ms.put(&quot;value&quot;,id); &#125;else&#123; //更新数据 ms.put(&quot;errorCode&quot;,&quot;00200&quot;); ms.put(&quot;errorMsg&quot;, &quot;新增数据失败&quot;); ms.put(&quot;value&quot;,&quot;&quot;); &#125; &#125; return JSON.toJSONString(ms); &#125; @GET @Path(&quot;/getProcess/&#123;productCode&#125;&quot;) //查询数据是否存在 public String selectEngineNumberInfoCount(@PathParam(&quot;productCode&quot;)String productCode) throws Throwable&#123; Map ms= new HashMap(); DataSource db = DataSourceHelper.getDataSource(&quot;default&quot;); //查询用户 String vininfo = &quot;SELECT a.PROCESSINSTID,a.PROPOSER,b.NAME DEPARTMENT,a.PHONE,c.NAME CATEGORY,d.NAME CARRYDEPARTMENT,a.PROPOSAL,a.ACTUALITY,a.IMPROVEMENT,a.SUBMITTIME,a.OPINION1,a.CHECKTIME,a.OPINION2,a.RECHECKTIME,a.STATE FROM ((ADVICE a LEFT JOIN DEPARTMENT b ON a.DEPARTMENT=b.DID)LEFT JOIN CATEGORY c ON a.CATEGORY=c.ID)LEFT JOIN CARRYDEPARTMENT d ON a.CARRYDEPARTMENT=d.ID WHERE PHONE = &#x27;&quot;+productCode+&quot;&#x27; ORDER BY PROCESSINSTID DESC&quot;; //获取密码 List list = getRsInfo.getRsListbySql(vininfo, db.getConnection()); return JSON.toJSONString(list); &#125;&#125; 创建配置文件在编辑的java同目录下创建文件restconfig.properties并录入以下内容（等号后是对应的类全名） 1resteasy.resources&#x3D;com.xcmg.service.ProcessStartService 编辑web.xml文件编辑web.xml文件，在rest.config.locations下的param-value标签下新增restconfig.properties对应路径，需要增加英文逗号与已有内容分开，保存编辑后需要右键web.xml文件进行部署。 注意事项：1.修改了web.xml要手动部署web.xml2.web.xml中的servlet-mapping下的url-pattern要和配置访问的地址对应3.在rest.config.locations下的param-value标签下新增restconfig.properties对应路径","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://zzy521.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"EOS","slug":"EOS","permalink":"https://zzy521.com/tags/EOS/"},{"name":"Rest接口","slug":"Rest接口","permalink":"https://zzy521.com/tags/Rest%E6%8E%A5%E5%8F%A3/"}]},{"title":"Markdown生成带侧边目录的HTML","slug":"Markdown生成带侧边目录的HTML","date":"2021-01-03T02:24:25.000Z","updated":"2021-05-20T09:43:04.992Z","comments":true,"path":"posts/7067bb35.html","link":"","permalink":"https://zzy521.com/posts/7067bb35.html","excerpt":"","text":"在使用Markdown文件生成说明文档的时候一般需要加侧边目录，但是Markdown本身的目录只能在上方显示，这里我选择使用一个插件来生成侧边目录。 安装插件使用了node.js，没有安装的话自己安装，安装插件下载过慢的话换淘宝源或者清华源 点击win+r，输入cmd点击回车打开。 输入 1npm install -g i5ting_toc 出现添加包成功代表安装成功 生成文件打开需要生成的md文件所在目录 在地址栏输入cmd点击回车。（这样操作省去了使用cd将目录移动到文件所在的文件夹的步骤） 输入 1i5ting_toc -f Tomcat的目录结构.md -o Tomcat的目录结构.md是我的文件名，需要根据自己的文件名去修改。 下面输出的三行分别为文件所在文件夹、目标文件和生成的文件。 推荐将Markdown中使用的图片都放在一个单独的文件夹，并将文件夹和Markdown放在一个文件夹中，将图片路径设置为相对路径，这样如果生成的HTML文件图片不显示只要将图片文件夹复制一份放到preview文件夹中就正常显示了。 可以看到生成的文件已经加了锚点，支持打开相应的链接直接跳转到相应的位置。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://zzy521.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://zzy521.com/tags/markdown/"},{"name":"项目说明","slug":"项目说明","permalink":"https://zzy521.com/tags/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/"}]},{"title":"Tomcat服务器介绍","slug":"Tomcat服务器介绍","date":"2021-01-02T09:01:32.000Z","updated":"2021-05-20T09:05:16.212Z","comments":true,"path":"posts/c86b9588.html","link":"","permalink":"https://zzy521.com/posts/c86b9588.html","excerpt":"","text":"Tomcat的目录结构解压下载好的tomcat可以看到如下文件结构： bin：存放启动和关闭tomcat的命令的路径。 conf：存放tomcat的配置，所有的tomcat的配置都在该路径下设置。 lib：存放Tomcat服务器的核心类库（JAR文件），如果需要扩展tomcat的功能，也可将第三方类库复制到该路径下。 logs：这是一个空路径，用来保存Tomcat每次运行后产生的日志。 temp：保存Web应用运行过程中生成的临时文件。 webapps：该路径用于自动部署Web应用，将Web应用复制到该路径下，Tomcat启动时会自动将该应用部署到容器中。 work：保存在Web应用在运行过程中编译生成的.class文件。该文件夹可以删除，但每次启动Tomcat时系统都会再次建立该路径。 LICENSE等相关文档 运行Tomcat只需要系统有一个JAVA_HOME环境变量。不管是Windows还是linux，只要有这个环境变量并且指向JDK的安装路径即可。 启动Tomcat对于Windows平台，只要双击Tomcat安装路径下bin目录中的startup.bat文件即可。 启动Tomcat后，打开浏览器并在地址栏输入http://localhost:8080/，浏览器出现此界面即表示安装成功。 配置Tomcat的端口Tomcat的默认端口是8080，可以通过修改Tomcat的配置文件来改变服务端口，甚至可以让Tomcat同时在多个端口提供服务。 Tomcat的配置文件在conf目录下，控制端口的配置文件为conf下的server.xml文件。切记修改时只能用记事本或者vi等无格式的编辑器，不可以使用写字板。 在service.xml的70行左右的位置，可以看到以下代码 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 其中port=&quot;8080&quot;就是Tomcat提供服务的端口，将Tomcat修改为任意的端口，为避免与公用端口产生冲突，端口号最好大于1024。在这里我修改为8090. 修改完之后重启Tomcat，在浏览器地址栏输入http://localhost:8090/,即可再次看到Tomcat的界面。 Tomcat的控制台在上图右上角有三个控制台：一个是Server Status控制台，一个是Manager APP控制台，一个是Host Mnager控制台。 Status用来监控服务器的状态，Manager控制台用来部署和监控Web应用，通常只需使用Manager控制台。 控制台的用户名和密码是通过Tomcat的JAAS（JAAS的全称是Java Authentication Authorization Service（Java验证和授权API），它用来控制对Java web应用的授权访问）控制的。初始是没有用户的，所以无论输入什么都无法登陆。 webapps路径是Web应用的存放路径，而Manager控制台对应的也是一个Web应用，所以它的配置文件是webapps/manager/WEB-INF路径下的web.xml文件。 用户的配置也在其中，但是Tomcat采用文件安全域，添加控制台用户只需要修改conf路径下的tomcat-users.xml文件即可。 打开该文件在 1&lt;tomcat-users&gt; 下方添加下列内容 12&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;user username=&quot;manager&quot; password=&quot;manager&quot; roles=&quot;manager-gui&quot;/&gt; 此处登录用户名和密码我都是用的manager，可以根据需要自行修改。 修改过后重启Tomcat点击控制台登录即可。 显示下图即表示登陆成功 Tomcat服务器状态","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zzy521.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://zzy521.com/tags/Tomcat/"}]},{"title":"Linux查看应用的端口号和进程号PID","slug":"Linux查看应用的端口号和进程号PID","date":"2020-12-22T09:57:25.000Z","updated":"2021-05-20T09:03:44.453Z","comments":true,"path":"posts/73a46000.html","link":"","permalink":"https://zzy521.com/posts/73a46000.html","excerpt":"","text":"1.进程名和进程号PID的互查1.1根据进程名查进程号PID(PID是进程标识符)1ps -ef | grep 进程名 比如：查看tomcat进程的PID编号 1ps -ef | grep tomcat 如图，第一个就是查到的PID编号 还可以使用ps -aux | grep xxx，效果与ps -ef | grep xxx一样，只不过信息会更详细。1ps -aux | grep 进程名 PID编号可以用来强制结束某进程。 1kill -9 PID编号 比如：强制结束tomcat进程 12#5087为上边查到的tomcat的PIDkill -9 5087 1.2根据进程号查进程名将上边的进程名换成进程号即可。（这个用的比较少，一般都是根据进程名去查进程号） 1ps -ef | grep 进程号 1ps -aux | grep 进程号 2.端口号和进程号PID的互查根据进程PID查端口号1lsof -i | grep 进程号 或使用 1netstat -nap | grep 进程号 根据端口号查进程号PID1lsof -i:端口号 或 1netstat -nap | grep 端口号","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zzy521.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zzy521.com/tags/Linux/"}]},{"title":"Hexo新建博客显示分类及标签","slug":"Hexo新建博客显示分类及标签","date":"2020-12-20T12:40:11.000Z","updated":"2021-05-20T08:07:41.845Z","comments":true,"path":"posts/4d9beafe.html","link":"","permalink":"https://zzy521.com/posts/4d9beafe.html","excerpt":"","text":"分类进入hexo博客所在的根目录，输入如下命令： 1hexo new page categories 成功后提示： 1INFO Created: D:\\Hexo\\source\\categories\\index.md index.md的内容如下： 1234---title: categoriesdate: 2020-12-20 20:26:06--- 需要修改为 1234567---title: 分类date: 2020-12-20 20:26:06type: &quot;categories&quot;layout: categoriescomments: false--- 标签在控制台中输入如下命令： 1hexo new page tags 成功后提示： 1INFO Created: D:\\Hexo\\source\\tags\\index.md index.md的内容如下： 1234---title: tagsdate: 2020-12-20 20:51:11--- 修改为 1234567---title: 标签date: 2020-12-20 20:51:11type: &quot;tags&quot;layout: tagscomments: false--- 修改模板修改scaffolds中的post模板 123456789---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: - 文章分类tags: - 文章标签toc: true---","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://zzy521.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zzy521.com/tags/Hexo/"}]},{"title":"在服务器上安装运行EOS的Tomcat的方法","slug":"在服务器上安装运行EOS的Tomcat的方法","date":"2020-12-19T09:01:25.000Z","updated":"2021-05-20T09:01:05.880Z","comments":true,"path":"posts/eba5960e.html","link":"","permalink":"https://zzy521.com/posts/eba5960e.html","excerpt":"","text":"1.防火墙开启端口号12345678910111213# 查看firewall的状态firewall-cmd --state# 开启（如果防火墙未开启的话先开启）service firewalld start# 查询端口是否开放firewall-cmd --query-port=8080/tcpfirewall-cmd --query-port=8009/tcp# 开放8080端口firewall-cmd --permanent --add-port=8080/tcp# 开放8009端口firewall-cmd --permanent --add-port=8009/tcp#重启防火墙(修改配置后要重启防火墙)firewall-cmd --reload 2.将压缩包复制到服务器并打开在/usr/local文件夹下新建名为tomcat的文件夹，将名为apache-tomcat-7.0.54.tar的压缩包进去 进入tomcat文件夹下 1cd /usr/local/tomcat 解压 1tar -xvf apache-tomcat-7.0.54.tar 3.调大Tomcat的jvm内存在生产环境中，tomcat内存设置不好很容易出现JVM内存溢出，解决方法就是修改Tomcat中的catalina.sh文件 1234567#进入bin目录下cd /usr/local/tomcat/apache-tomcat-7.0.54/bin#打开catalina.sh文件vi catalina.sh#按i进入编辑模式，找到cygwin=false，在这一行的前面加入参数，具体如下，按Esc退出编辑模式，再输入:wq！点击回车保存JAVA_OPTS=&quot;-server -Xms800m -Xmx800m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m&quot; 其他说明： “m”说明单位是MB，否则默认是KB 一般使用物理内存的80%作为堆大小 一般把-Xms和-Xmx设为一样大 一般把-Xmn设置为-Xmx值的1/4 一般将堆的总大小的50%到60%分配给新生成的池 jvm参数说明： -server 一定要作为第一个参数，启用JDK的server版本，在多个CPU时性能佳-Xms java Heap初始大小。 默认是物理内存的1/64。-Xmx java heap最大值。建议均设为物理内存的80%。不可超过物理内存。-Xmn java heap最小值，一般设置为Xmx的3、4分之一。-XX:PermSize 设定内存的永久保存区初始大小，缺省值为64M。-XX:MaxPermSize 设定内存的永久保存区最大大小，缺省值为64M。-XX:SurvivorRatio=2 生还者池的大小，默认是2。如-XX:NewSize 新生成的池的初始大小。 缺省值为2M。-XX:MaxNewSize 新生成的池的最大大小。 缺省值为32M。+XX:AggressiveHeap 让jvm忽略Xmx参数，疯狂地吃完一个G物理内存，再吃尽一个G的swap。-Xss 每个线程的Stack大小-verbose:gc 现实垃圾收集信息-Xloggc:gc.log 指定垃圾收集日志文件-XX:+UseParNewGC 缩短minor收集的时间-XX:+UseConcMarkSweepGC 缩短major收集的时间-XX:userParNewGC 可用来设置并行收集(多CPU)-XX:ParallelGCThreads 可用来增加并行度(多CPU)-XX:UseParallelGC 设置后可以使用并行清除收集器(多CPU) 4.改变端口号如果不用默认的8080端口则需要修改端口号，在conf文件夹下的server.xml文件中修改。换端口号的话需要在防火墙开启相应的端口号，参考第一步。（如果使用默认的8080端口则跳过此步骤） 12345678#进入conf目录下cd /usr/local/tomcat/apache-tomcat-7.0.54/conf#打开server.xml文件vi server.xml#按i进入编辑模式，找到 &lt;Connector URIEncoding=&quot;UTF-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;，#将其中的8080换为需要的端口号，例如8090，按Esc退出编辑模式，再输入:wq！点击回车保存&lt;Connector URIEncoding=&quot;UTF-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8090&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 5.启动运行1234#进入bin目录下cd /usr/local/tomcat/apache-tomcat-7.0.54/bin#启动运行./startup.sh 部署完项目需要重启tomcat 123456#进入bin目录下cd /usr/local/tomcat/apache-tomcat-7.0.54/bin#停止运行./shutdown.sh#启动运行./startup.sh","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zzy521.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"EOS","slug":"EOS","permalink":"https://zzy521.com/tags/EOS/"},{"name":"Linux","slug":"Linux","permalink":"https://zzy521.com/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://zzy521.com/tags/Tomcat/"}]}],"categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://zzy521.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"CRM","slug":"CRM","permalink":"https://zzy521.com/categories/CRM/"},{"name":"Java","slug":"Java","permalink":"https://zzy521.com/categories/Java/"},{"name":"Python","slug":"Python","permalink":"https://zzy521.com/categories/Python/"},{"name":"服务器","slug":"服务器","permalink":"https://zzy521.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zzy521.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQLserver","slug":"SQLserver","permalink":"https://zzy521.com/tags/SQLserver/"},{"name":"时间函数","slug":"时间函数","permalink":"https://zzy521.com/tags/%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/"},{"name":"钉钉","slug":"钉钉","permalink":"https://zzy521.com/tags/%E9%92%89%E9%92%89/"},{"name":"用户信息","slug":"用户信息","permalink":"https://zzy521.com/tags/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"},{"name":"vue接口同步调用","slug":"vue接口同步调用","permalink":"https://zzy521.com/tags/vue%E6%8E%A5%E5%8F%A3%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8/"},{"name":"二进制","slug":"二进制","permalink":"https://zzy521.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"钉钉消息","slug":"钉钉消息","permalink":"https://zzy521.com/tags/%E9%92%89%E9%92%89%E6%B6%88%E6%81%AF/"},{"name":"java","slug":"java","permalink":"https://zzy521.com/tags/java/"},{"name":"SQLServer","slug":"SQLServer","permalink":"https://zzy521.com/tags/SQLServer/"},{"name":"Java","slug":"Java","permalink":"https://zzy521.com/tags/Java/"},{"name":"a++","slug":"a","permalink":"https://zzy521.com/tags/a/"},{"name":"位运算","slug":"位运算","permalink":"https://zzy521.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"类型转换","slug":"类型转换","permalink":"https://zzy521.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"python","slug":"python","permalink":"https://zzy521.com/tags/python/"},{"name":"excel","slug":"excel","permalink":"https://zzy521.com/tags/excel/"},{"name":"EOS","slug":"EOS","permalink":"https://zzy521.com/tags/EOS/"},{"name":"Linux","slug":"Linux","permalink":"https://zzy521.com/tags/Linux/"},{"name":"exe","slug":"exe","permalink":"https://zzy521.com/tags/exe/"},{"name":"Rest接口","slug":"Rest接口","permalink":"https://zzy521.com/tags/Rest%E6%8E%A5%E5%8F%A3/"},{"name":"markdown","slug":"markdown","permalink":"https://zzy521.com/tags/markdown/"},{"name":"项目说明","slug":"项目说明","permalink":"https://zzy521.com/tags/%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://zzy521.com/tags/Tomcat/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zzy521.com/tags/Hexo/"}]}